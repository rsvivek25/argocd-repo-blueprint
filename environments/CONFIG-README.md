# External ConfigMap Management

This directory contains **application-specific ConfigMaps** that are managed outside of Helm charts, typically generated by DevOps pipelines.

## Structure

```
environments/
├── cldev01/
│   ├── config/
│   │   ├── app1/
│   │   │   └── application-config.yaml    # App1 ConfigMap for cldev01
│   │   ├── app2/
│   │   │   └── application-config.yaml    # App2 ConfigMap for cldev01
│   │   └── app3/
│   │       └── application-config.yaml    # App3 ConfigMap for cldev01
│   ├── values/
│   └── ...
├── cldev02/
│   └── config/
│       ├── app1/
│       ├── app2/
│       └── app3/
└── clat01/
    └── config/
        ├── app1/
        ├── app2/
        └── app3/
```

## Purpose

These ConfigMaps are:
- ✅ **Generated by DevOps pipelines** (not manually edited)
- ✅ **Environment-specific** (different per namespace)
- ✅ **Workload-specific** (different per application)
- ✅ **Auto-deployed by ArgoCD** via ApplicationSet discovery
- ✅ **Independent of Helm charts** (separate lifecycle)

## How It Works

### 1. ArgoCD ApplicationSet Discovery

The ApplicationSet is configured to include config files:

```yaml
# In environments/{env}/applicationset.yaml
spec:
  template:
    spec:
      sources:
        # Source 1: Helm chart
        - repoURL: https://github.com/your-org/argocd-pilot.git
          targetRevision: main
          path: charts/{{path.basename}}
          helm:
            valueFiles:
              - ../../environments/{env}/values/{{path.basename}}-values.yaml
        
        # Source 2: External config directory
        - repoURL: https://github.com/your-org/argocd-pilot.git
          targetRevision: main
          path: environments/{env}/config/{{path.basename}}
          directory:
            recurse: false
```

### 2. Pipeline Integration

Your DevOps pipeline should:

```bash
# Example CI/CD pipeline step
# 1. Generate ConfigMap from application config
cat > environments/${ENVIRONMENT}/config/${APP_NAME}/application-config.yaml <<EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: ${APP_NAME}-application-config
  namespace: ${ENVIRONMENT}
  labels:
    app: ${APP_NAME}
    environment: ${ENVIRONMENT}
    managed-by: devops-pipeline
  annotations:
    pipeline.run: "${BUILD_ID}"
    generated.at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
data:
  application.yaml: |
    $(cat config/application.yaml | sed 's/^/    /')
EOF

# 2. Commit and push
git add environments/${ENVIRONMENT}/config/${APP_NAME}/
git commit -m "Update ${APP_NAME} config for ${ENVIRONMENT} - Build ${BUILD_ID}"
git push

# 3. ArgoCD auto-syncs the change
```

### 3. ConfigMap Mounting

The Helm chart deployment can mount this ConfigMap:

```yaml
# In your pod spec (charts/app1/templates/deployment.yaml)
volumeMounts:
  - name: app-config
    mountPath: /config/application.yaml
    subPath: application.yaml
volumes:
  - name: app-config
    configMap:
      name: app1-application-config  # External ConfigMap
```

## File Naming Convention

- **File name**: `application-config.yaml` (or any `.yaml` file)
- **ConfigMap name**: `{app}-application-config`
- **Namespace**: Must match the environment namespace

## DevOps Pipeline Workflow

```
┌─────────────────┐
│  Build Pipeline │
│  (CI/CD)        │
└────────┬────────┘
         │
         │ 1. Generate config
         │ 2. Create ConfigMap YAML
         │ 3. Commit to Git
         ▼
┌─────────────────────────────────┐
│  environments/{env}/config/     │
│    └── {app}/                   │
│        └── application-config.  │
│            yaml                 │
└────────┬────────────────────────┘
         │
         │ Git push
         ▼
┌─────────────────┐
│  GitHub Repo    │
└────────┬────────┘
         │
         │ ArgoCD polls/webhook
         ▼
┌─────────────────┐
│  ArgoCD         │
│  Auto-Sync      │
└────────┬────────┘
         │
         │ kubectl apply
         ▼
┌─────────────────┐
│  Kubernetes     │
│  ConfigMap      │
└─────────────────┘
```

## Example ConfigMaps

### Application Configuration
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app1-application-config
  namespace: cldev01
data:
  application.yaml: |
    database:
      host: dev-db.cldev01.svc.cluster.local
      port: 5432
    features:
      newUI: false
      analytics: true
```

### Feature Flags
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app1-feature-flags
  namespace: cldev01
data:
  features.json: |
    {
      "enableNewCheckout": false,
      "enableRecommendations": true
    }
```

### Environment-Specific Endpoints
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app1-endpoints
  namespace: cldev01
data:
  endpoints.properties: |
    api.url=http://api.cldev01.svc.cluster.local
    auth.url=http://auth.cldev01.svc.cluster.local
```

## Benefits

### ✅ Separation of Concerns
- **Helm charts**: Infrastructure/deployment logic
- **ConfigMaps**: Application configuration
- **Values files**: Environment-specific overrides

### ✅ Pipeline-Friendly
- Generate configs during build
- Commit to Git (GitOps)
- ArgoCD auto-deploys
- No manual kubectl apply

### ✅ Environment Isolation
- Each environment has its own config directory
- No risk of cross-environment contamination
- Clear directory structure

### ✅ Multi-Source Applications
- Helm chart + External configs in one Application
- Single ArgoCD sync applies both
- Maintains proper ordering

## Multiple ConfigMaps

You can have multiple ConfigMap files per workload:

```
environments/cldev01/config/app1/
├── application-config.yaml
├── feature-flags.yaml
├── database-config.yaml
└── api-endpoints.yaml
```

All `.yaml` files in the directory will be applied by ArgoCD.

## Best Practices

### 1. Always Set Namespace
```yaml
metadata:
  namespace: cldev01  # REQUIRED - must match environment
```

### 2. Use Labels
```yaml
labels:
  app: app1
  environment: cldev01
  managed-by: devops-pipeline
```

### 3. Add Annotations for Tracking
```yaml
annotations:
  pipeline.run: "BUILD-12345"
  generated.at: "2025-11-12T10:30:00Z"
  git.commit: "abc123def"
```

### 4. Validate Before Commit
```bash
# Validate YAML syntax
yamllint environments/cldev01/config/app1/application-config.yaml

# Validate Kubernetes schema
kubectl apply --dry-run=client -f environments/cldev01/config/app1/application-config.yaml
```

### 5. Use Immutable ConfigMaps (Optional)
```yaml
metadata:
  name: app1-config-v123  # Versioned name
immutable: true
```

Then update pod spec to reference new version.

## Updating Configuration

### Manual Update (Not Recommended)
```bash
# Edit file
vim environments/cldev01/config/app1/application-config.yaml

# Commit
git add environments/cldev01/config/app1/
git commit -m "Update app1 config for cldev01"
git push

# ArgoCD syncs automatically
```

### Pipeline Update (Recommended)
```bash
# Your pipeline generates and commits
./scripts/generate-config.sh --app app1 --env cldev01 --build ${BUILD_ID}
git push
# ArgoCD syncs automatically
```

## Troubleshooting

### ConfigMap Not Applied
```bash
# Check ArgoCD Application
kubectl get application app1-cldev01 -n argocd

# Check sync status
argocd app get app1-cldev01

# Manual sync
argocd app sync app1-cldev01
```

### ConfigMap Not Mounted in Pod
```bash
# Check if ConfigMap exists
kubectl get configmap app1-application-config -n cldev01

# Check pod events
kubectl describe pod <pod-name> -n cldev01

# Verify mount
kubectl exec -it <pod-name> -n cldev01 -- ls -la /config/
```

### Wrong Namespace
If ConfigMap is in wrong namespace, update the YAML:
```yaml
metadata:
  namespace: cldev01  # Must match environment
```

## Migration from Helm ConfigMaps

If you currently have ConfigMaps in Helm charts:

### Before (In Helm Chart)
```yaml
# charts/app1/templates/configmap.yaml
{{- if .Values.configMap.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "app1.fullname" . }}
data:
  {{- toYaml .Values.configMap.data | nindent 2 }}
{{- end }}
```

### After (External)
```yaml
# environments/cldev01/config/app1/application-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app1-application-config
  namespace: cldev01
data:
  application.yaml: |
    # Your config here
```

Set `configMap.enabled: false` in values files to disable Helm-managed ConfigMap.

## Security Considerations

### ❌ Don't Store Secrets Here
Use Kubernetes Secrets or External Secrets Operator for sensitive data:
```yaml
# DON'T DO THIS
data:
  database.password: "plaintext-password"  # ❌ Bad

# DO THIS INSTEAD - Reference a Secret
env:
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: app1-secrets
        key: database-password
```

### ✅ Use for Non-Sensitive Config Only
- Feature flags
- API endpoints (internal)
- Application settings
- Routing rules
- Cache TTLs

## Summary

| Aspect | Details |
|--------|---------|
| **Location** | `environments/{env}/config/{app}/*.yaml` |
| **Managed By** | DevOps Pipeline |
| **Deployed By** | ArgoCD (auto-sync) |
| **Lifecycle** | Independent from Helm charts |
| **Use Case** | Pipeline-generated app config |
| **Format** | Standard Kubernetes ConfigMap YAML |
